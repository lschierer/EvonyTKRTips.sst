---

import { getCollection, type CollectionEntry } from "astro:content";
import type { HTMLAttributes} from 'astro/types'

import { z  } from "astro:content";

import {TableContainer} from './tableContainer'

import { Debug } from 'astro:components';


import {
  AscendingLevels,
  type BuffType,
  Condition,
  qualityColor,
  syslogSeverity,
} from "@schemas/baseSchemas";

import {
  ConflictArray, 
  ConflictDatum,   
  type bookConflictsType,
  type ConflictDatumType,
 } from '@schemas/conflictSchemas'

 import {
  Note,
  Display,
  type NoteType,
  GeneralArray,
  GeneralElement,
  type GeneralArrayType,
  type GeneralElementType,
  generalSpecialists
 } from '@schemas/generalsSchema'

 import { 
  type ExtendedGeneralType,
  ExtendedGeneralStatus,
  } from "@schemas/ExtendedGeneral";

import { 
  type BookType,
  specialSkillBook,
  standardSkillBook,
  type specialSkillBookType,
  type standardSkillBookType,
 } from "@schemas/bookSchemas";

const dataUrl = new URL("/generals/all.json", Astro.url);
const conflictData = new URL("/generalConflictData/conflicts.json", Astro.url);

let allGeneralsJson = "";
const generalObjects: CollectionEntry<"generals">[] =
  await getCollection("generals");
if (generalObjects !== null && generalObjects !== undefined) {
  let generalIterator = generalObjects.values();
  let allGenerals = new Array<GeneralElementType>();
  for (const v of generalIterator) {
    const validation = GeneralElement.safeParse(v.data);
    if (validation.success) {
      if (validation.data.general.score_as === generalSpecialists.enum.Mayor) {
        allGenerals.push(validation.data);
      }
    } else {
      console.error(`bad validation ${validation.error}`);
    }
  }
  allGeneralsJson = JSON.stringify(allGenerals);
}

let allGenerals: GeneralArrayType | null = null;
let allGeneralsString: string | null = null;
let result:
  | { success: true; data: GeneralArrayType }
  | { success: false; error: z.ZodError } = GeneralArray.safeParse(
  JSON.parse(allGeneralsJson)
);
if (result.success) {
  console.log(`validation passed`);
  if (result.data !== undefined && result.data !== null) {
    console.log(`and has data`);
    allGenerals = result.data;
    allGeneralsString = JSON.stringify(result.data);
  }
} else {
  console.error(result.error);
}

let allConflictJson = "";
const collectionArray: CollectionEntry<"generalConflictData">[] =
  await getCollection("generalConflictData");
if (collectionArray !== null && collectionArray !== undefined) {
  let result = collectionArray.map((ca) => {
    const validation = ConflictDatum.safeParse(ca.data);
    if (validation.success) {
      return validation.data;
    } else {
      console.error(`bad validation ${validation.error}`);
    }
  });
  allConflictJson = JSON.stringify(result);
}

const result2 = ConflictArray.safeParse(JSON.parse(allConflictJson));
let allConflictData: string | null = null;
if (result2.success) {
  if (result2.data !== undefined && result2.data !== null) {
    let Returnable = new Map<string, standardSkillBookType[]>();
    result2.data.map((datum: ConflictDatumType) => {
      let conflicts = datum.conflicts;
      let match = false;
      if(conflicts !== null && conflicts !== undefined) {
        for (const key in conflicts) {
          if(key.localeCompare('other')) {
            const items = conflicts[key];
            if(items !== undefined && Array.isArray(items) && items.length > 0) {
              let tg = allGenerals?.filter((g) => {
                return items.includes(g.general.name);
              })
              if(tg !== null && tg !== undefined) {
                match = true;      
              }
            }
          }
        }
      }
      if(match === true) {
        let result3 = standardSkillBook.array().safeParse(datum.books);
        if(result3.success) {
          let books = result3.data;
          if(books !== null && books !== undefined) {
            for (const key in conflicts) {
              if (key.localeCompare('other')) {
                const items = conflicts[key];
                if(items !== undefined && Array.isArray(items) && items.length > 0) {
                  items.forEach((g: string) => {
                    Returnable.set(g, books);
                  })
                }
              }
            }
          }
        }
      }
    })
    allConflictData = JSON.stringify(Returnable)
  }
} else {
  console.error(result2.error);
  return null;
}
---

{(allGeneralsString !== null) && <TableContainer allGenerals={allGeneralsString} client:only="lit" ></TableContainer> }



