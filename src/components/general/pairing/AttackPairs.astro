---
export const prerender = false;

import { getCollection, type CollectionEntry, z } from "astro:content";
import type { ComponentProps } from "astro/types";

import { ulid } from "ulidx";

import {delay} from 'nanodelay';

import { DisplayGrid} from './display-grid';


import {
  AscendingLevels,
  type BuffType,
  type BuffParamsType,
  ClassEnum,
  type ClassEnumType,
  Condition,
  type levelsType,
  qualityColor,
  type qualityColorType,
  syslogSeverity,
} from "@schemas/baseSchemas";

import {
  ConflictArray, 
  ConflictDatum,   
  type bookConflictsType,
  type ConflictDatumType,
 } from '@schemas/conflictSchemas'

 import {
  Note,
  Display,
  type NoteType,
  GeneralArray,
  type GeneralClassType,
  GeneralElement,
  type GeneralArrayType,
  type GeneralElementType,
  generalSpecialists,
  type generalUseCaseType,
 } from '@schemas/generalsSchema'

 import { 
  type ExtendedGeneralType,
  ExtendedGeneralStatus,
  type GeneralPairType,
  } from "@schemas/ExtendedGeneral";

import { 
  type BookType,
  specialSkillBook,
  standardSkillBook,
  type specialSkillBookType,
  type standardSkillBookType,
 } from "@schemas/bookSchemas";

const DEBUG = false;

interface Props {
  generalClass: ClassEnumType
}

const {generalClass} = Astro.props;

const table_name = `${Astro.url.pathname}-${ulid()}`

let allGenerals = new Array<GeneralElementType>();

//while no general can *have* both, I can evaluate generals assuming I will give them whichever that particular one needs.
let MyInvestmentLevel: BuffParamsType = {
  special1: qualityColor.enum.Gold,
  special2: qualityColor.enum.Gold,
  special3: qualityColor.enum.Gold,
  special4: qualityColor.enum.Gold,
  special5: qualityColor.enum.Disabled,
  stars: AscendingLevels.enum[10],
  dragon: true,
  beast: true,
};

const generalObjects: CollectionEntry<"generals">[] =
  await getCollection("generals");

if (generalObjects !== null && generalObjects !== undefined) {
  let generalIterator = generalObjects.values();

  for (const v of generalIterator) {
    const validation = GeneralElement.safeParse(v.data);
    if (validation.success) {
      if(generalClass.localeCompare(ClassEnum.enum.all)){
        if (validation.data.general.score_as === generalClass) {
          allGenerals.push(validation.data);
        }
      } else {
        allGenerals.push(validation.data);
      }
    } else {
      console.error(`bad validation ${validation.error.message}`);
    }
  }
  await Promise.all(allGenerals.map(async (g) => {
    if (DEBUG) console.log(`adding ${g.general.name}`)
    Astro.locals.addEG2EGS(g.general);
    const eg: ExtendedGeneralType = Astro.locals.ExtendedGenerals.find((thisG: ExtendedGeneralType) => {
      if(!thisG.general.name.localeCompare(g.general.name)) {
        return true;
      }
      return false;
    })
    if(eg !== undefined) {
      let generalIsProcessing = true;
      do{
        if(!ExtendedGeneralStatus.enum.complete.localeCompare(eg.status)){
          generalIsProcessing = false;
        } else {
          await delay(10)
        }
      } while(generalIsProcessing)
    }
  }));
  if(Array.isArray(Astro.locals.CachedPairs) && Astro.locals.CachedPairs.length > 0) {
    Astro.locals.CachedPairs.forEach((pair: GeneralPairType)=> {
      const egP = Astro.locals.ExtendedGenerals.find((thisg: ExtendedGeneralType) => {
        if(!thisg.general.name.localeCompare(pair.primary)) {
          return true;
        }
        return false;
      })
      const egS = Astro.locals.ExtendedGenerals.find((thisg: ExtendedGeneralType) => {
        if(!thisg.general.name.localeCompare(pair.secondary)) {
          return true;
        }
        return false;
      })
      const pKey = Astro.locals.InvestmentOptions2Key(MyInvestmentLevel);
      const pEvAnsRanking = egP.computedBuffs.get(pKey).EvAns 
      const pAttackRanking = egP.computedBuffs.get(pKey).AttackRank
      const pDefenseRanking = egP.computedBuffs.get(pKey).DefenseRank

      const sInvestment: BuffParamsType = {
        special1: MyInvestmentLevel.special1,
        special2: MyInvestmentLevel.special2,
        special3: MyInvestmentLevel.special3,
        special4: MyInvestmentLevel.special4,
        special5: MyInvestmentLevel.special5,
        stars: AscendingLevels.enum[0],
        dragon: MyInvestmentLevel.dragon,
        beast: MyInvestmentLevel.beast
      }
      const sKey = Astro.locals.InvestmentOptions2Key(sInvestment)
      const sEvAnsRanking = egS.computedBuffs.get(sKey).EvAns 
      const sAttackRanking = egS.computedBuffs.get(sKey).AttackRank
      const sDefenseRanking = egS.computedBuffs.get(sKey).DefenseRank

      pair.EvAnsRanking = (pEvAnsRanking + sEvAnsRanking)
      pair.AttackRanking = (pAttackRanking + sAttackRanking)
      pair.DefenseRanking = (pDefenseRanking + sDefenseRanking)

    })
    
  }
}



---

<div class="table-container">
  <!-- <DisplayGrid
    tableName={table_name}
    InvestmentLevel={MyInvestmentLevel}
    DisplayPairs={Astro.locals.CachedPairs}
    client:only="lit"
  >

  </DisplayGrid> -->
  
<style>
  .table-container {
    display: block;
    flex: 2 0 auto;
    
  }
</style>
